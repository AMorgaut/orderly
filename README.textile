<html>
<head><title> orderly </title></head>
<body>

h1. orderly -- v0 -- 05.10.2009

h2. abstract

Orderly is an ergonomic micro-language that can represent a subset of "JSONSchema":http://json-schema.org.  Orderly is designed to _feel_ familiar to the average programmer and to be extremely easy to learn and remember.

h2. WARNING

This proposal is HIGHLY subject to change and evolve in drastic ways.  This is not yet real, do not believe it in.

h2. a subset of JSONSchema

JSONSchema is good in many ways, but not perfect.  JSONSchema attempts to provide a representation for three distinct types of information about JSON structures:
* Data structure (for documentation and validation purposes)
* Storage attributes (to provide hints for tools that wish to persist JSON data) 
* Metadata for Interaction Control (to provide hints on how to render a UI where data can be manipulated).

Orderly ignores all features of JSONSchema which aren't useful for validation, including the following attributes:
 
* options (label/value)
* title
* description
* transient
* hidden
* disallow
* extends
* identity

h2. a non-normative tutorial

A collection of Non-normative examples of Orderly:

h3. comments and whitespace

Orderly supports comments, both '#' and '//'.

Orderly doesn't rely overlymuch on whitespace, leaving the decision of how to format your schema up to you.   

h3. type names

Type names may be anything that is allowed inside "JSON strings":http://json.org/.  Unlike JSON itself, however, orderly provides a shorthand where a subset of strings may be represented without quotes.  For instance these are all valid orderly:

bc.     string foo;
    string "foo";
    string "this is a property name with spaces"; 

h3. common properties

From the JSONSchema specification, the following four options exist which apply to all data types:

The @optional@ property indicates a value which is not required in a conformant JSON instance.  Optional values are represented in orderly with a trailing question mark:

bc.     string name?;
    string "name"?;


The @requires@ property indicates a that if a value is present in the instance JSON, another named value must also be present. 

bc.     string town <state>;
 
The @enum@ propery specifies a set of allowable values for a key in the json document.

bc.     string mood [ "happy", "sad", "meh" ];
    integer secretOfLife [ 7, 42 ];

In a JSONSchema document the @default@ property specifies a default value for a property.  One could imagine that as an input object passes validation it will be automatically augmented with default values for required properties missing in the instance object.

bc.     string mood [ "happy", "sad", "meh" ] = "happy"; # optimistically default to "happy"

h3. string types

Strings are specified in orderly using the @string@ type specifier.  Strings in JSONSchema support "minLength" and "maxLength" properties, this are represented using curly braces immediately after the type:  

bc.     string{4,12} login;

Omission of a specification of either minimum or maximum is allowed:

bc.     string{4,} login; # login requires at least 4 chars
    string{,32} name; # name may not be longer than 32 chars

Regular expressions are supported in JSONSchema for string values.  In orderly you may directly provide a regular expression using '/' syntax to denote the beginning and end of the regular expression:

bc.     string mood /^((happy)|(sad)|(meh))$/;

h3. number & integer types

Numbers are specified in orderly using the @number@ type specifier.  In JSONSchema numbers and integers support ranges, ranges for numbers are specified in the same way we specify ranges for strings:

bc.     number{0.02, 0.98} numNum;
    integer{0,10} rating;

Syntactically, numbers in orderly follow the same rules as numbers in JSON.

h3. boolean types

Boolean types are represented in orderly using the @boolean@ type specifier:

bc.     boolean iShouldStay;

h3. object types

XXX

h3. array types

Arrays are specified using the @array@ type specifier.  Schemas for arrays elements may be specified in one of two ways.  First we can specify a single schema that governs all array members:

bc.     array {
        numbers{0.00, 1.00};
    } weights; # an array of floating point weights between 0 and 1.

The second way of specifying sub-structure is via "tuple typing", where you may specify a list of schemas that apply to each member of the array in sequence:

bc.     array {
        integer;
        string;
        number;
    } artificial;

*NOTE to self*: we must figure out @additionalProperties@ for both array and object...

Finally, array types also support range semantics, for min/max number of elements:

bc.     array { integer; } {0,10} myArrayOfSmallInts;


h3. null types

The null type in JSONSchema specifies a value that must be null.  The @null@ type specifier in orderly supports this type:

bc. null likeAir;

As explained in the JSONSchema proposal, @null@ is useful "mainly for purpose of being able use union types to define nullability".  For example:

bc.     union {
        string [ "Sr.", "Jr.", "III" ];
        null; 
    } suffix;

h3. any types

"Any types" are represented in orderly using the @any@ type speicifier: 

bc.     any notes;

h3. references

*TODO*.  We'll probably use the @reference@ type specifier and allow the consumer to override the value name.  for example:

bc.      object {
        string name;
        string title;
        ref "http://json-schema.org/card" secretary;
        array {
            ref "http://json-schema.org/card";
        } reports;
    } employee;

h3. more complex examples

A number with a range, and enumerated possible values, and a default:

bc. integer powerOfTwo{0,256} [1,2,4,8,16,32,64,128,256] = 1;

An object with enumerated possible values and a default.

bc.     object {
      string beast;
      number normalTemperature;
    } temps [ { "beast": "canine", "normalTemperature": 101.2 },
        { "beast": "human", "normalTemperature": 98.6 } ]
      = { "beast": "human", "normalTemperature": 101.2 };


h3. gotchas

When you stare hard enough at the grammar of a non-trival language you usually learn quite a deal.  Sometimes what you learn can be surprising or downright confusing.  Here's a tour of the darker parts alleys of orderly:

Brackets and braces -- visually a tad confusing:

bc.     integer{7,42} secretOfLife[7,42];

and a little bit more confusing:

bc.     array { integer{7,42}[7,42]; } secretOfLife;

... add ugly stuff here ...

h2. The normative grammar...

... doesn't yet exist.

h2. Contributing

This specification, orderly-json.org, and the orderly reference implementation are all <a href="http://github.com/lloyd/orderly">hosted on github</a>, you may fork all you like.

h2. Contributors

Many people have offered feedback and ideas which shaped this project.  Those people include (in alphabetical order):

* Alexandre Morgaut  	 	
* David Grigsby
* Hatem Nassrat 
* Steve Spencer
* Tatu Saloranta
* Toby Inkster

h2. History

* (02.10.2009) "v-1" -- The idea for orderly was "first uttered":http://trickyco.de/2009/10/02/orderly-jsonschema
* (05.10.2009) "v0" -- "orderly-json.org":http://orderly-json.org was erected and a more fully baked proposal put together thanks to feedback.

h2. License

All the cruft you find here is covered under a BSD style license, even if it's not approprately marked.  The act of forking this project on github is implicit permission to pull back your contributions and redistribute them under this same license.

<pre>
 Copyright 2009, Lloyd Hilaiel.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:
 
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
 
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
 
  3. Neither the name of Lloyd Hilaiel nor the names of its
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
</pre>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10971932-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
